#ifndef CVP
#include "Game.h"
DWORD Game::insertBase = 0;
DWORD Game::argsAddr = 0;
HANDLE Game::hProcess;
DWORD mBase;
void Game::writeptr(DWORD Address, LPVOID ptr, int size) {
	WriteProcessMemory(hProcess, (LPVOID)Address, ptr, size, nullptr);
}
void Game::readptr(DWORD Address, LPVOID ptr, int size) {
	ReadProcessMemory(hProcess, (LPVOID)Address, ptr, size, nullptr);
}
void Game::entrLock(bool a) {
	write(0x62E897ul, a ? 0xFEEBu : 0x54EBu, 2);
}
bool Game::start(const wchar_t* pvzPath, const wchar_t* dllPath) {
	STARTUPINFOW si = { sizeof(si) };
	PROCESS_INFORMATION pi;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = true;
	if (!CreateProcessW(pvzPath, nullptr, nullptr, nullptr, false, CREATE_SUSPENDED, nullptr, nullptr, &si, &pi))return false;
	WaitForInputIdle(pi.hThread, INFINITE);
	hProcess = pi.hProcess;
	if (!hProcess)return false;
	if (0x49ECF563ul != read<DWORD>(0x400008ul + read<DWORD>(0x40003Cul))) {
		MessageBoxW(0, (wstring(L"需要版本v1.0.0.1051,发现不符合的版本") + pvzPath).data(), L"游戏版本错误", 0);
		ResumeThread(pi.hThread);
		CloseHandle(pi.hThread);
		TerminateProcess(hProcess, 0);
		release();
		return false;
	}
	printf(u8"%s\n", Template::convert<string>(pvzPath).data());
	//加锁
	entrLock(true);
	//释放进程
	ResumeThread(pi.hThread);
	CloseHandle(pi.hThread);
	//禁止删档
	write(0x4336fdul, 0xebu, 1);
	//禁止直接进入主界面
	write(0x48e3e7ul, 0xebu, 1);
	//修复全屏闪退
	write(0x54DFE4ul, 0x65u, 1);
	//高性能
	write(0x6a66f4ul, 0x0u, 1);
	//
	write(0x6217cbul, 0x0000000035ffull, 6);
	//挂接自身dll
	argsAddr = (DWORD)VirtualAllocEx(hProcess, nullptr, 0x1000ul, MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);
	insertBase = rLoadDll(dllPath);
	printf(u8"%x_%s\n", insertBase, u8"base");
	//解放权限
	const DWORD* idata_ptr = (DWORD*)mBase;
	while (*idata_ptr != 0x6164722Eul)++idata_ptr;
	idata_ptr = (DWORD*)(*(idata_ptr + 3) + mBase);
	DWORD temp;
	VirtualProtect((LPVOID)mBase, (DWORD)idata_ptr - mBase, PAGE_EXECUTE_READWRITE, &temp);
	Cvp::RegWrite((HMODULE)insertBase, u8"cvpMain");
	return true;
}
void Game::release() {
	entrLock(false);
	if (hProcess) {
		if (argsAddr) VirtualFreeEx(hProcess, (LPVOID)argsAddr, 0, MEM_RELEASE);
		CloseHandle(hProcess);
	}
	hProcess = 0;
	insertBase = 0;
	argsAddr = 0;
}
DWORD Game::rLoadDll(const wchar_t* dllPath) {
	DWORD uni_code = Cvp::RegRead<DWORD>(u8"uni_code");
	writeptr(argsAddr, (LPVOID)&uni_code, sizeof(DWORD));
	writeptr(sizeof(DWORD) + argsAddr, (LPVOID)dllPath, sizeof(wchar_t) * (1 + wcslen(dllPath)));
	BYTE newloaddll__[] = {
		0xE8u, 0x00u, 0x00u, 0x00u, 0x00u, 0x58u, 0x83u, 0xC0u, 0x13u, 0x81u, 0x30u, 0x55u, 0x55u, 0x55u, 0x55u, 0x83u,
		0xC0u, 0x04u, 0x83u, 0x38u, 0x00u, 0x75u, 0xF2u, 0x8Bu, 0x11u, 0x71u, 0x51u, 0xD6u, 0x95u, 0x51u, 0x05u, 0x05u,
		0xAAu, 0x40u, 0x05u, 0x74u, 0x30u, 0x55u, 0x05u, 0x3Du, 0x51u, 0x54u, 0x55u, 0x55u, 0xAAu, 0x21u, 0x71u, 0x5Du,
		0x3Fu, 0x55u, 0xAAu, 0x40u, 0x39u, 0x75u, 0x30u, 0x55u, 0xDEu, 0x11u, 0x71u, 0x51u, 0x64u, 0x9Cu, 0x3Cu, 0x9Cu,
		0xD6u, 0x55u, 0x55u, 0x55u, 0xDEu, 0x45u, 0xD4u, 0xB7u, 0xAAu, 0x55u, 0x55u, 0x55u, 0x54u, 0x84u, 0x15u, 0xD5u,
		0x6Du, 0x55u, 0x20u, 0xBFu, 0x0Du, 0xDEu, 0x41u, 0x71u, 0xDCu, 0x57u, 0x0Du, 0x6Eu, 0x1Fu, 0xA9u, 0x21u, 0x4Du,//0xC5u, 0xC5u,
		0xDCu, 0x1Fu, 0xA9u, 0x3Fu, 0x55u, 0x3Fu, 0x55u, 0xBDu, 0x55u, 0x55u, 0x55u, 0x55u, 0xD6u, 0x51u, 0x71u, 0x58u,
		0x3Fu, 0x55u, 0xAAu, 0x40u, 0x0Du, 0x76u, 0x30u, 0x55u, 0x96u, 0x79u, 0x32u, 0xF2u, 0x1Bu, 0x94u, 0x01u, 0x6Fu,
		0x1Bu, 0x18u, 0x04u, 0x6Cu, 0xD8u, 0x55u, 0x0Au, 0xC5u, 0x3Bu, 0x3Au, 0xDAu, 0xA3u, 0x1Bu, 0x79u, 0x55u, 0xD4u,
		0x2Cu, 0x37u, 0x3Eu, 0x7Du, 0x20u, 0xDBu, 0x1Bu, 0x13u, 0x00u, 0x4Fu, 0x1Bu, 0x7Du, 0x20u, 0x41u, 0xC5u, 0x79u,
		0x55u, 0x33u, 0xDEu, 0x80u, 0x35u, 0x85u, 0x36u, 0xCEu, 0x1Au, 0x50u, 0xD5u, 0xD1u, 0x23u, 0x63u, 0x30u, 0x6Cu,
		0xD8u, 0xD4u, 0xDCu, 0x17u, 0x39u, 0x58u, 0x55u, 0x01u, 0x55u, 0x3Du, 0x55u, 0x3Cu, 0x55u, 0x26u, 0x55u, 0x75u,
		0x55u, 0x25u, 0x55u, 0x27u, 0x55u, 0x3Au, 0x55u, 0x31u, 0x55u, 0x20u, 0x55u, 0x36u, 0x55u, 0x21u, 0x55u, 0x75u,
		0x55u, 0x3Cu, 0x55u, 0x26u, 0x55u, 0x75u, 0x55u, 0x3Au, 0x55u, 0x25u, 0x55u, 0x30u, 0x55u, 0x3Bu, 0x55u, 0x75u,
		0x55u, 0x26u, 0x55u, 0x3Au, 0x55u, 0x20u, 0x55u, 0x27u, 0x55u, 0x36u, 0x55u, 0x30u, 0x55u, 0x75u, 0x55u, 0x34u,
		0x55u, 0x3Bu, 0x55u, 0x31u, 0x55u, 0x75u, 0x55u, 0x33u, 0x55u, 0x27u, 0x55u, 0x30u, 0x55u, 0x30u, 0x55u, 0x79u,
		0x55u, 0x75u, 0x55u, 0x3Cu, 0x55u, 0x21u, 0x55u, 0x72u, 0x55u, 0x26u, 0x55u, 0x75u, 0x55u, 0x34u, 0x55u, 0x39u,
		0x55u, 0x39u, 0x55u, 0x3Au, 0x55u, 0x22u, 0x55u, 0x30u, 0x55u, 0x31u, 0x55u, 0x75u, 0x55u, 0x33u, 0x55u, 0x3Au,
		0x55u, 0x27u, 0x55u, 0x75u, 0x55u, 0x3Bu, 0x55u, 0x3Au, 0x55u, 0x75u, 0x55u, 0x36u, 0x55u, 0x3Au, 0x55u, 0x38u,
		0x55u, 0x38u, 0x55u, 0x30u, 0x55u, 0x27u, 0x55u, 0x36u, 0x55u, 0x3Cu, 0x55u, 0x34u, 0x55u, 0x39u, 0x55u, 0x75u,
		0x55u, 0x20u, 0x55u, 0x26u, 0x55u, 0x30u, 0x55u, 0x79u, 0x55u, 0x37u, 0x55u, 0x30u, 0x55u, 0x75u, 0x55u, 0x34u,
		0x55u, 0x39u, 0x55u, 0x30u, 0x55u, 0x27u, 0x55u, 0x21u, 0x55u, 0x75u, 0x55u, 0x21u, 0x55u, 0x3Au, 0x55u, 0x75u,
		0x55u, 0x36u, 0x55u, 0x3Du, 0x55u, 0x34u, 0x55u, 0x27u, 0x55u, 0x32u, 0x55u, 0x3Cu, 0x55u, 0x3Bu, 0x55u, 0x32u,
		0x55u, 0x75u, 0x55u, 0x33u, 0x55u, 0x27u, 0x55u, 0x3Au, 0x55u, 0x38u, 0x55u, 0x75u, 0x55u, 0x21u, 0x55u, 0x3Du,
		0x55u, 0x30u, 0x55u, 0x75u, 0x55u, 0x25u, 0x55u, 0x27u, 0x55u, 0x3Au, 0x55u, 0x23u, 0x55u, 0x3Cu, 0x55u, 0x31u,
		0x55u, 0x30u, 0x55u, 0x27u, 0x55u, 0x7Bu, 0x55u, 0x55u, 0x55u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u,
	};
	LPVOID func = VirtualAllocEx(hProcess, nullptr, 416, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!func) Cvp::error(u8"VirtualAllocEx failed");
	writeptr((DWORD)func, (LPVOID)&newloaddll__[0], 416);
	HANDLE hThread = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE)func, (LPVOID)argsAddr, 0, nullptr);
	if (!hThread) Cvp::error(u8"CreateRemoteThread failed");
	WaitForSingleObject(hThread, INFINITE);
	VirtualFreeEx(hProcess, func, 0, MEM_RELEASE);
	Cvp::RegWrite(read<DWORD>(argsAddr), u8"uni_code");
	return read<DWORD>(sizeof(DWORD) + argsAddr);
}
DWORD Game::rLoadCvp(const wchar_t* path) {
	writeptr(argsAddr, (LPVOID)path, sizeof(wchar_t) * (1 + wcslen(path)));
	HANDLE hThread = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE)((DWORD)&__loadCvp - mBase + insertBase), (LPVOID)argsAddr, 0, nullptr);
	if (hThread)WaitForSingleObject(hThread, INFINITE);
	return read<DWORD>(argsAddr);
}
void Game::__loadCvp(const wchar_t* path) {
	DWORD& ans = *(DWORD*)path;
	HMODULE base = LoadLibraryW(path);
	if (!base) {
		ans = 1;//失败
		FreeLibrary(base);
		return;
	}
	void(__stdcall * reheap_old)(DWORD) = (void(__stdcall*)(DWORD))GetProcAddress(base, u8"_cvp_ex_reheap@4");
	if (reheap_old) {
		ans = 4;//插件版本过低
		FreeLibrary(base);
		return;
	}
	DWORD(__cdecl * version)(void) = (DWORD(__cdecl*)(void))GetProcAddress(base, u8"cvp_ex_getversion");
	if (!version) {
		ans = 2;//错误
		FreeLibrary(base);
		return;
	}
	if (version() > cvp_version) {
		ans = 3;//加载器版本过低
		FreeLibrary(base);
		return;
	}
	void(__cdecl * func)(void) = (void(__cdecl*)(void))GetProcAddress(base, u8"cvp_ex_init");
	if (func) Cvp::__cvpinit_fnal(func);
	ans = 0;//成功
	return;
}
extern"C" void __declspec(dllexport)__stdcall dll_init(const wchar_t* myPath) {
	system(u8"chcp 65001");
	mBase = (DWORD)GetModuleHandleW(myPath);
	printf(u8"%s\n%s\n%s\n",
		u8"请将修改器置于pvz.exe所在文件夹内",
		u8"自动加载修改器路径下所有cvp插件",
		u8"F4切换窗口模式"
	);
	wchar_t loaderPath[MAX_PATH];
	GetModuleFileNameW(0, loaderPath, MAX_PATH);
	wchar_t* loader = loaderPath + wcslen(loaderPath);
	while (*--loader != L'\\');
	++loader;
	WIN32_FIND_DATAW FindFileData;
	HANDLE hFile = FindFirstFileW(L"*.exe", &FindFileData);
	if (hFile != INVALID_HANDLE_VALUE)do if (wcscmp(FindFileData.cFileName, loader) && Game::start(FindFileData.cFileName, myPath)) goto gamefound; while (FindNextFileW(hFile, &FindFileData));
	MessageBoxW(0, L"未找到正确版本的植物大战僵尸程序", L"error", 0);
	return;
gamefound:
	FindClose(hFile);
	char* ans[5] = { u8"成功",u8"失败",u8"错误",u8"加载器版本过低",u8"插件版本过低" };
	hFile = FindFirstFileW(L"*.cvp", &FindFileData);
	if (hFile != INVALID_HANDLE_VALUE)do printf(u8"%s %s\n", ans[Game::rLoadCvp(FindFileData.cFileName)], Template::convert<string>(FindFileData.cFileName).data()); while (FindNextFileW(hFile, &FindFileData));
	FindClose(hFile);
	//system("pause");
	//解锁游戏进程
	Game::entrLock(false);
	//自动关闭
	DWORD p = 0;
	while (!p)p = Game::read<DWORD>(0x6A9EC0ul);
	p += 0x770u;
	while (!Game::read<DWORD>(p));
	Game::release();
}
#endif